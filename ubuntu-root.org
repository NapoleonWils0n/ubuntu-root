#+TITLE: ubuntu root dotfiles
#+STARTUP: content
#+STARTUP: overview hideblocks
#+OPTIONS: num:nil author:nil
#+PROPERTY: header-args :mkdirp yes
* tangle dotfiles
** tangle document

C-c C-v t

** tangle only one code block

C-u C-c C-v t

** tangle from the command line

tangle file from the command line
where ~/git/ubuntu-dotfiles/ubuntu-dotfiles.org is the path of the file to tangle

#+begin_src sh
emacs --batch -l org --eval '(org-babel-tangle-file "~/git/ubuntu-dotfiles/ubuntu-dotfiles.org")'
#+end_src
* ubuntu root dotfiles
** doas
*** doas config

#+NAME: doas
#+BEGIN_SRC sh
# check config : doas -C /etc/doas.conf

# allow user
permit keepenv djwilcox

# apt update and upgrade without a password
permit nopass djwilcox cmd apt args update
permit nopass djwilcox cmd apt args upgrade

# mount and unmount drives 
permit nopass djwilcox cmd mount 
permit nopass djwilcox cmd umount 

# zfs and zpool
permit nopass djwilcox cmd zfs 
permit nopass djwilcox cmd zpool 

# allow root to switch to our user
permit nopass setenv { PATH } root as djwilcox

# namespace command
permit nopass setenv { PATH } djwilcox cmd namespace

# vpn
permit nopass djwilcox cmd vpn-netns

# root as root
permit nopass keepenv setenv { PATH } root as root
#+END_SRC

*** doas tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ home dir

#+NAME: doas-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/etc/doas.conf"
<<doas>>
#+END_SRC
  
+ current dir

#+NAME: doas-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "etc/doas.conf"
<<doas>>
#+END_SRC

** /usr/local/bin
*** /usr/local/bin config
**** blackrain

#+NAME: blackrain
#+begin_src sh
#!/bin/sh

# transmission fzf menu

# if transmission-daemon isnt running start it
transmission-remote -l >/dev/null 2>&1 || transmission-daemon && sleep 0.1

# input = list of torrents
input=$(transmission-remote -l \
| head -n -1 \
| awk 'NR == 1; NR > 1 {print $0 | "sort -k 2 -n"}' \
| fzf --multi --info=inline --layout=reverse --header-lines=1 --delimiter='\n' --prompt='Select Torrents: ' | awk '{print $1}')


# exit script if no torrents are selected (e.g hit ESC)
if [ "${input}" = "" ]; then exit; fi


# main trd function
trd() {
    printf "%s\n" "${input}" | \
    while read line
    do
      transmission-remote -t"${line}" "${1}" ;
    done
    }


# get files from torrent
get_files() {
    printf "%s\n" "${input}" | \
    while read line
    do
	selection=$(transmission-remote -t"${line}" --info-files \
		| fzf --multi --info=inline --layout=reverse --header-lines=2 --delimiter='\n' --prompt='Select Files: ' \
		| awk -F':' -v RS="\n" '{print $1}' | awk 'a++{printf ","}{printf "%s", $1}')
	transmission-remote -t"${line}" -g"${selection}";
    done
    }


# dont get files from torrent
noget_files() {
    printf "%s\n" "${input}" | \
    while read line
    do
	selection=$(transmission-remote -t"${line}" --info-files \
		| fzf --multi --info=inline --layout=reverse --header-lines=2 --delimiter='\n' --prompt='Select Files: ' \
		| awk -F':' -v RS="\n" '{print $1}' | awk 'a++{printf ","}{printf "%s", $1}')
	transmission-remote -t"${line}" -G"${selection}";
    done
    }


# fzf prompt variables spaces to line up menu options
start_menu='start      - start torrent'
pause_menu='pause      - pause torrent'
info_menu='info       - show torrent info'
files_menu='files      - show files in torrent'
get_files_menu='get        - get items in torrent'
noget_files_menu='noget      - noget items in torrent'
peers_menu='peers      - ask for more peers'
remove_menu='remove     - remove torrent'
purge_menu='purge      - remove torrent and data'


# fzf prompt to specify function to run on links from ytfzf
menu=$(printf "%s\n" \
	      "${start_menu}" \
	      "${pause_menu}" \
	      "${info_menu}" \
	      "${files_menu}" \
	      "${get_files_menu}" \
	      "${noget_files_menu}" \
	      "${peers_menu}" \
	      "${remove_menu}" \
	      "${purge_menu}" \
	      | fzf --delimiter='\n' --prompt='Run transmission function: ' --info=inline --layout=reverse --no-multi)


# case statement to run function based on fzf prompt output
case "${menu}" in
   start*) trd --start;;
   pause*) trd --stop;;
   info*) trd --info;;
   peers*) trd --reannounce;;
   files*) trd --info-files;;
   get*) get_files;;
   noget*) noget_files;;
   remove*) trd --remove;;
   purge*) trd --remove-and-delete;;
   ,*) exit;;
esac
#+end_src

**** chromium-netns

#+NAME: chromium-netns
#+begin_src sh
#!/bin/sh

sh -c "HOME=${HOME} PULSE_SERVER=/run/user/$(id -u "${USER}")/pulse/native PULSE_COOKIE=/home/${USER}/.config/pulse/cookie \
BAMF_DESKTOP_FILE_HINT=/var/lib/snapd/desktop/applications/chromium_chromium.desktop \
/snap/chromium/current/usr/lib/chromium-browser/chrome"
#+end_src

**** firefox-netns

#+NAME: firefox-netns
#+begin_src sh
#!/bin/sh

# firefox namespace

sh -c "HOME=${HOME} PULSE_SERVER=/run/user/$(id -u "${USER}")/pulse/native PULSE_COOKIE=/home/${USER}/.config/pulse/cookie \
BAMF_DESKTOP_FILE_HINT=/var/lib/snapd/desktop/applications/firefox_firefox.desktop \
/snap/firefox/current/usr/lib/firefox/firefox"
#+end_src

**** magnet-add

#+NAME: magnet-add
#+begin_src sh
#!/bin/sh

# transmission add magnet link from browser

transmission-remote --add "$@"
#+end_src

**** namespace

#+NAME: namespace
#+begin_src sh
#!/bin/sh

# open in namespace
ip netns exec vpn doas -u djwilcox -- "$@"
#+end_src

**** netns-vpn

#+NAME: netns-vpn
#+begin_src sh
#!/bin/sh

# openvpn split route with namespace
#===================================

# openvpn up script
up() {
    # create network namespace
    ip netns add vpn || true

    # bring up loop device
    ip netns exec vpn ip link set dev lo up

    # move VPN tunnel to netns
    ip link set dev "$1" up netns vpn mtu "$2"

    # configure tunnel in netns
    ip netns exec vpn ip addr add dev "$1" \
            "$4/${ifconfig_netmask:-30}" \
            ${ifconfig_broadcast:+broadcast "$ifconfig_broadcast"}
    if [ -n "$ifconfig_ipv6_local" ]; then
            ip netns exec vpn ip addr add dev "$1" \
                    "$ifconfig_ipv6_local"/112
    fi

    # set route in netns
    ip netns exec vpn ip route add default via "$route_vpn_gateway"

    # create vpn namespace directory
    mkdir -p /etc/netns/vpn

    # create resolv.conf with 
    echo 'nameserver 127.0.0.1' > /etc/netns/vpn/resolv.conf 

    # stop unbound dns server
    systemctl stop unbound.service

    # sleep for 1 second
    sleep 1

    # start unbound dns server in vpn namespace
    systemctl start unbound-netns.service
}

# openvpn down script
down() {
    # remove namespace and delete resolv.conf
    rm -rf /etc/netns/vpn
    ip netns delete vpn

    # restart unbound dns server
    systemctl stop unbound-netns.service

    # sleep for 1 second
    sleep 1

    # start unbound dns server
    systemctl start unbound.service

    true
}

"$script_type" "$@"
#+end_src

**** openvpn-down

#+NAME: openvpn-down
#+begin_src sh
#!/bin/sh

# openvpn-down
#=============

# clear unbound_outgoing_interface
echo > /etc/unbound/unbound_outgoing_interface

# comment out include
sed -i '/include: "\/etc\/unbound\/unbound_outgoing_interface"/s/^/#/' /etc/unbound/unbound.conf.d/custom.conf

# sleep for 1 second
sleep 1

# restart unbound dns server
systemctl restart unbound.service
#+end_src

**** openvpn-up

#+NAME: openvpn-up
#+begin_src sh
#!/bin/sh

# openvpn-up
#===========

# echo tun0 ip address to unbound_outgoing_interface
echo "outgoing-interface: $(ip a list tun0 \
| grep inet | head -1 | awk '{print $2}' | cut -d'/' -f1)" > /etc/unbound/unbound_outgoing_interface

# uncomment include
sed -i '/include: "\/etc\/unbound\/unbound_outgoing_interface"/s/#//' /etc/unbound/unbound.conf.d/custom.conf

# sleep for 1 second
sleep 1

# restart unbound dns server
systemctl restart unbound.service
#+end_src

**** vpn-netns

#+NAME: vpn-netns
#+begin_src sh
#!/bin/sh

# openvpn split route
#====================

#===============================================================================
# script usage
#===============================================================================

usage () {
# if argument passed to function echo it
[ -z "${1}" ] || echo "! ${1}"
# display help
echo "\
$(basename "$0") -c infile.ovpn -a auth.txt"
exit 2
}


#===============================================================================
# error messages
#===============================================================================

ROOT_ERR="$(basename "$0") must be run as root"
WRONG_ARGS_ERR='wrong number of arguments passed to script'
INVALID_OPT_ERR='Invalid option:'
REQ_ARG_ERR='requires an argument'
NOTFILE_ERR='not a file'


#===============================================================================
# check if script is run as root
#===============================================================================

[ "$(id -u)" -eq 0 ] || usage "${ROOT_ERR}"


#===============================================================================
# check number of aruments passed to script
#===============================================================================

[ $# -gt 0 ] || usage "${WRONG_ARGS_ERR}"


#===============================================================================
# getopts check options passed to script
#===============================================================================

while getopts ':c:a:h' opt
do
  case ${opt} in
     c) config="${OPTARG}"
     [ -f "${config}" ] || usage "${config} ${NOTFILE_ERR}";;
     a) auth="${OPTARG}"
     [ -f "${auth}" ] || usage "${auth} ${NOTFILE_ERR}";;
     h) usage;;
     \?) usage "${INVALID_OPT_ERR} ${OPTARG}" 1>&2;;
     :) usage "${INVALID_OPT_ERR} ${OPTARG} ${REQ_ARG_ERR}" 1>&2;;
  esac
done
shift $((OPTIND-1))


#===============================================================================
# openvpn code
#===============================================================================

openvpn \
--auth-nocache --script-security 2 --route-nopull --redirect-gateway \
--ifconfig-noexec --route-noexec \
--up /usr/local/bin/netns-vpn --down /usr/local/bin/netns-vpn \
--config "${config}" \
--mute-replay-warnings \
--auth-user-pass "${auth}"
#+end_src

**** vpn-route

#+NAME: vpn-route
#+begin_src sh
#!/bin/sh

# openvpn split route
#====================

#===============================================================================
# script usage
#===============================================================================

usage () {
# if argument passed to function echo it
[ -z "${1}" ] || echo "! ${1}"
# display help
echo "\
$(basename "$0") -c infile.ovpn -a auth.txt"
exit 2
}


#===============================================================================
# error messages
#===============================================================================

ROOT_ERR="$(basename "$0") must be run as root"
WRONG_ARGS_ERR='wrong number of arguments passed to script'
INVALID_OPT_ERR='Invalid option:'
REQ_ARG_ERR='requires an argument'
NOTFILE_ERR='not a file'


#===============================================================================
# check if script is run as root
#===============================================================================

[ "$(id -u)" -eq 0 ] || usage "${ROOT_ERR}"


#===============================================================================
# check number of aruments passed to script
#===============================================================================

[ $# -gt 0 ] || usage "${WRONG_ARGS_ERR}"


#===============================================================================
# getopts check options passed to script
#===============================================================================

while getopts ':c:a:h' opt
do
  case ${opt} in
     c) config="${OPTARG}"
     [ -f "${config}" ] || usage "${config} ${NOTFILE_ERR}";;
     a) auth="${OPTARG}"
     [ -f "${auth}" ] || usage "${auth} ${NOTFILE_ERR}";;
     h) usage;;
     \?) usage "${INVALID_OPT_ERR} ${OPTARG}" 1>&2;;
     :) usage "${INVALID_OPT_ERR} ${OPTARG} ${REQ_ARG_ERR}" 1>&2;;
  esac
done
shift $((OPTIND-1))


#===============================================================================
# openvpn code
#===============================================================================

openvpn \
--auth-nocache --route-nopull --script-security 2 --redirect-gateway \
--up /usr/local/bin/openvpn-up --down /usr/local/bin/openvpn-down \
--config "${config}" \
--mute-replay-warnings \
--auth-user-pass "${auth}"
#+end_src

*** /usr/local/bin tangle
**** blackrain tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: blackrain-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/blackrain" :tangle-mode (identity #o755)
<<blackrain>>
#+END_SRC
  
+ current dir

#+NAME: blackrain-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/blackrain"
<<blackrain>>
#+END_SRC

**** chromium-netns tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: chromium-netns-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/chromium-netns" :tangle-mode (identity #o755)
<<chromium-netns>>
#+END_SRC
  
+ current dir

#+NAME: chromium-netns-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/chromium-netns"
<<chromium-netns>>
#+END_SRC

**** firefox-netns tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: firefox-netns-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/firefox-netns" :tangle-mode (identity #o755)
<<firefox-netns>>
#+END_SRC
  
+ current dir

#+NAME: firefox-netns-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/firefox-netns"
<<firefox-netns>>
#+END_SRC

**** magnet-add tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: magnet-add-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/magnet-add" :tangle-mode (identity #o755)
<<magnet-add>>
#+END_SRC
  
+ current dir

#+NAME: magnet-add-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/magnet-add"
<<magnet-add>>
#+END_SRC

**** namespace tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: namespace-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/namespace" :tangle-mode (identity #o755)
<<namespace>>
#+END_SRC
  
+ current dir

#+NAME: namespace-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/namespace"
<<namespace>>
#+END_SRC

**** netns-vpn tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: netns-vpn-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/netns-vpn" :tangle-mode (identity #o755)
<<netns-vpn>>
#+END_SRC
  
+ current dir
  
#+NAME: netns-vpn-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/netns-vpn"
<<netns-vpn>>
#+END_SRC

**** openvpn-down tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: openvpn-down-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/openvpn-down" :tangle-mode (identity #o755)
<<openvpn-down>>
#+END_SRC
  
+ current dir

#+NAME: openvpn-down-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/openvpn-down"
<<openvpn-down>>
#+END_SRC

**** openvpn-up tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: openvpn-up-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/openvpn-up" :tangle-mode (identity #o755)
<<openvpn-up>>
#+END_SRC
  
+ current dir

#+NAME: openvpn-up-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/openvpn-up"
<<openvpn-up>>
#+END_SRC

**** vpn-netns tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: vpn-netns-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/vpn-netns" :tangle-mode (identity #o755)
<<vpn-netns>>
#+END_SRC
  
+ current dir

#+NAME: vpn-netns-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/vpn-netns"
<<vpn-netns>>
#+END_SRC

**** vpn-route tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: vpn-route-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/local/bin/vpn-route" :tangle-mode (identity #o755)
<<vpn-route>>
#+END_SRC
  
+ current dir

#+NAME: vpn-route-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/local/bin/vpn-route"
<<vpn-route>>
#+END_SRC

** xmonad xsession
*** xmonad xsession config

#+NAME: xmonad-xsession
#+BEGIN_SRC conf
[Desktop Entry]
Name=XMonad
Comment=Lightweight tiling window manager
Exec=/home/djwilcox/.cache/xmonad/xmonad-x86_64-linux
Type=XSession
#+END_SRC

*** xmonad xession tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: xmonad-xsession-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/share/xsessions/xmonad.desktop" :tangle-mode (identity #o644)
<<xmonad-xsession>>
#+END_SRC
  
+ current dir

#+NAME: xmonad-xsession-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/share/xsessions/xmonad.desktop"
<<xmonad-xsession>>
#+END_SRC

** zsh vendor-completions
*** zsh vendor-completions config
**** playerctl config

#+NAME: playerctl
#+BEGIN_SRC conf
#compdef playerctl

typeset -A opt_args
__playerctl() {
	command playerctl "$@" 2>/dev/null
}

__playerctl_ctx() {
	local -a player_opts=(
		${(kv)opt_args[(I)-p|--player]}
		${(kv)opt_args[(I)-i|--ignore-player]}
		${(kv)opt_args[(I)-a|--all-players]}
	)
	__playerctl "$player_opts[@]" "$@"
}

local -a playercmd_loop=(/$'(none|track|playlist)\0'/ ':(none track playlist)')
local -a playercmd_shuffle=(/$'(on|off)\0'/ ':(on off)')

(( $+functions[_playerctl_players] )) ||
_playerctl_players() {
	local -a players=( ${(@f)"$(__playerctl --list-all)"} )
	players+=( "%all" )
	compadd "$@" -a players
}

(( $+functions[_playerctl_metadata_keys] )) ||
_playerctl_metadata_keys() {
	local -a keys
	__playerctl_ctx metadata |
	while read PLAYER KEY VALUE; do
		keys+="$KEY"
	done
	_multi_parts "$@" -i ":" keys
}
local -a playerctl_command_metadata_keys=(/$'[^\0]#\0'/ ':keys:key:_playerctl_metadata_keys')

local -a playerctl_command
_regex_words commands 'playerctl command' \
	'play:Command the player to play' \
	'pause:Command the player to pause' \
	'play-pause:Command the player to toggle between play/pause' \
	'stop:Command the player to stop' \
	'next:Command the player to skip to the next track' \
	'previous:Command the player to skip to the previous track' \
	'position:Command the player to go or seek to the position' \
	'volume:Print or set the volume level from 0.0 to 1.0' \
	'status:Get the play status of the player' \
	'metadata:Print the metadata information for the current track:$playerctl_command_metadata_keys' \
	'open:Command the player to open the given URI' \
	'loop:Print or set the loop status:$playercmd_loop' \
	'shuffle:Print or set the shuffle status:$playercmd_shuffle'
playerctl_command=( /$'[^\0]#\0'/ "$reply[@]" )
_regex_arguments _playerctl_command "$playerctl_command[@]"

_arguments -S -s\
	'(-h --help)'{-h,--help}'[Show help message and quit]' \
	'(-v --version)'{-v,--version}'[Print version information and quit]' \
	'(-l --list-all)'{-l,--list-all}'[List all available players]' \
	'(-F, --follow)'{-F,--follow}'[Bock and append the query to output when it changes]' \
	'(-f --format)'{-f,--format=}'[Format string for printing properties and metadata]' \
	'(-i --ignore-player)'{-i,--ignore-player=}'[Comma separated list of players to ignore]:players:_sequence _playerctl_players' \
	'(-a --all-players)'{-a,--all-players}'[Control all players instead of just the first]' \
	'(-p --player)'{-p,--player=}'[Comma separated list of players to control]:players:_sequence _playerctl_players' \
	'*::playerctl command:= _playerctl_command'
#+END_SRC

*** zsh vendor-completions tangle
**** playerctl tangle
:PROPERTIES:
:ORDERED:  t
:END:

+ root dir

#+NAME: playerctl-root-dir
#+BEGIN_SRC conf :noweb yes :tangle "/doas::/usr/share/zsh/vendor-completions/_playerctl" :tangle-mode (identity #o644)
<<playerctl>>
#+END_SRC
  
+ current dir

#+NAME: playerctl-current-dir
#+BEGIN_SRC conf :noweb yes :tangle "usr/share/zsh/vendor-completions/_playerctl"
<<playerctl>>
#+END_SRC
